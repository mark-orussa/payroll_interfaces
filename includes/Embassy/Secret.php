<?php

/**
 * Created by PhpStorm.
 * User: morussa
 * Date: 9/15/2016
 * Time: 12:22 PM
 */
namespace Embassy;

use Exception, Defuse\Crypto as C;

class Secret {
	/*
	 * There are some things we want to keep secret, such as  database user names and passwords. This class makes it easier to manage hiding these secrets. It uses the Defuse-Crypto library to encrypt the secrets. Learn more at https://github.com/defuse/php-encryption.
	 *
	 * The process of keeping things a secret looks like this:
	 * 1. Create an encryption key. We need this to encrypt and decrypt our secrets. This will make the secrets unreadable and cannot be decrypted without this key.
	 * 2. Store the key on the server. It should not be in the web root or any publicly accessible directory. You can try to give it a non-obvious name, but it will be in your php code any way.
	 * 3. Encrypt the secrets using the above key and the Defuse-Crypto library.
	 * 4. Save the encrypted secrets in some kind of file format (XML, YAML, text, csv) and store somewhere outside the web root that is not publicly accessible. Again, you can try to make the file name non-obvious, but you will have to expose it when you go to retrieve the encrypted secrets.
	 * 5. When you want to get the secrets, use the key to decrypt them.
	 *
	 */

	private $key;
	private $Debug;
	private $Message;

	public function __construct($Debug, $Message, $keyPath) {
		/**
		 * Config_Secret constructor. Give it the location of the key and secrets files. These two files should not be stored in the same location.
		 * @param $keyPath                string    The absolute path to the key, starting with a slash (i.e. /var/www). The key is the string generated by the encryption library.
		 * @param $secretsFileLocation    string    The full system path to the secrets file, starting with a slash (i.e. /var/www).
		 */
		$this->Debug = $Debug;
		$this->Message = &$Message;
		$this->Debug->newFile('includes/Embassy/Secrets.php');
		try{
			// Read the key file.
			if( !file_exists($keyPath) ){
				throw new CustomException('', 'File does not exist: ' . $keyPath);
			}
			if( !is_readable($keyPath) ){
				throw new CustomException('', 'File is not readable: ' . $keyPath);
			}
			$handle = fopen($keyPath, 'r');
			$key = fread($handle, filesize($keyPath));
			$this->key = C\Key::loadFromAsciiSafeString($key);
		}catch( CustomException$exception ){
		}
	}

	public static function generateKey() {
		// You shouldn't need to use this very often. Generate a key and save it in a key file.
		$key = C\Key::createNewRandomKey();
		return $key->saveToAsciiSafeString();
	}

	public function encrypt($string) {
		/**
		 * @param $string    string    The string data that you want to encrypt.
		 * @return string    Returns the encrypted string or an error message about not having generating a key.
		 */
		$output = '';
		if( empty($this->key) ){
			$output = 'You must generate a key first.';
		}else{
			$output = C\Crypto::encrypt($string, $this->key);// Save this. It is the encrypted data.
		}
		return $output;
	}

	public function decrypt($cipherString, $key = false) {
		/**
		 * @param $string    string    The string data to decrypt.
		 * @return string    The decrypted string data.
		 */
		$output = '';
		try{
			$key = $key == false ? $this->key : $key;
			$output .= C\Crypto::decrypt($cipherString, $key);
		}catch( C\Exception\WrongKeyOrModifiedCiphertextException $ex ){
			$this->Debug->error(__LINE__,'','Wrong key or modified cipher text when trying to decrypt.',$this->Message, $this->Debug);
			// An attack! Either the wrong key was loaded, or the ciphertext has
			// changed since it was created -- either corrupted in the database or
			// intentionally modified by someone trying to carry out an attack.
			// ... handle this case in a way that's suitable to your application ...
		}
		return $output;
	}
}